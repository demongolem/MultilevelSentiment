APNS_MAX_NOTIFICATION_SIZE
Simple example of use: class OrderShippedPush ( PushNotification ): message = _ ( 'Order no. {{item.pk}} has been shipped.' ) # ... somewhere in a view OrderShippedPush ( item = order , receivers = [ user ], context = {}) . send () Unsubscriber
This section refers to all notifications except WebSockets, which by default are not prone to unsubscriptions (however this can be changed by setting check_subscription to True).
Each category for each type must be explicitly declared in config (with label). If it is not there, exception will be raised on attempt to send such notification. This requirement is to prevent situation, that notification of given type is send to user who would not wish to receive it, but cannot unsubscribe from it (since it is not present in the config).
Since categories can be changed with configuration, labels should be specified for them, since they can't be hardcoded in client's app.
There is one special category: "system". This category should not be declared in configuration, and notification with such category will always pass.
Sample configuration: UNIVERSAL_NOTIFICATIONS_CATEGORIES = { "push" : { "default" : _ ( "This is a label for default category you'll send to FE" ), "chat" : _ ( 'Category for chat messages' ), "promotions" : _ ( 'Promotions' ,) }, "email" : { "default" : _ ( "This is a label for default category you'll send to FE" ), "chat" : _ ( 'Category for chat messages' ), "newsletter" : _ ( 'Newsletter' ,) }, "sms" : { "default" : _ ( "This is a label for default category you'll send to FE" ), "chat" : _ ( 'Category for chat messages' ), "newsletter" : _ ( 'Newsletter' ,) }, "test" : { "default" : _ ( "This is a label for default category you'll send to FE" ), }, },
If you want to allow different types of users to have different categories of notifications, you can do it with configuration: # not required. If defined, specific types of users will only get notifications from allowed categories. # requires a bit more configuration - helper function to check if notification category is allowed for user UNIVERSAL_NOTIFICATIONS_USER_CATEGORIES_MAPPING = { "for_admin" : { "push" : [ "default" , "chat" , "promotions" ], "email" : [ "default" , "chat" , "newsletter" ], "sms" : [ "default" , "chat" , "newsletter" ] }, "for_user" : { "push" : [ "default" , "chat" , "promotions" ], "email" : [ "default" , "newsletter" ], # chat skipped "sms" : [ "default" , "chat" , "newsletter" ] } }, # path to the file we will import user definitions for UNIVERSAL_NOTIFICATIONS_USER_CATEGORIES_MAPPING UNIVERSAL_NOTIFICATIONS_USER_DEFINITIONS_FILE = 'tests.user_conf' # from file: tests/user_conf.py def for_admin ( user ): return user . is_superuser def for_user ( user ): return not user . is_superuser
In the example above, functions "for_admin" & "for_user" should be defined in file tests/user_conf.py. Each function takes user as a parameter, and should return either True or False.
If given notification type is not present for given user, user will neither be able to receive it nor unsubscribe it. Unsubscriber API
The current subscriptions can be obtained with a API described below. Please note, that API does not provide label for "unsubscribe_from_all", since is always present and can be hardcoded in FE module. Categories however may vary, that's why labels for them must be returned from BE. # GET /subscriptions return { "unsubscribe_from_all" : bool , # False by default "each_type_for_given_user" : { "each_category_for_given_type_for_given_user" : bool , # True(default) if subscribed, False if unsubscribed "unsubscribe_from_all" : bool # False by default } "labels" : { "each_type_for_given_user" : { "each_category_for_given_type_for_given_user" : string , } } }
Unsubscriptions may be edited using following API: # PUT /subscriptions data = { "unsubscribe_from_all" : bool , # False by default "each_type_for_given_user" : { "each_category_for_given_type_for_given_user" : bool , # True(default) if subscribed, False if unsubscribed "unsubscribe_from_all" : bool # False by default } }
Please note, that if any type/category for type is ommited, it is reseted to default value. FakeEmailSend view
universal_notifications.backends.emails.views.FakeEmailSend is a view that helps testing email templates. To start using it, add url(r'^emails/', include('universal_notifications.backends.emails.urls')) to your urls.py, and specify receiver email address using UNIVERSAL_NOTIFICATIONS_FAKE_EMAIL_TO .
After that you can make a request to the new url with template parameter, for instance: http://localhost:8000/emails/?template=reset_password , which will send an email using emails/email_reset_password.html as the template. Notification history
By default all notifications that have been sent are stored in the NotificationHistory object in the database, but this behavior can be changed, and therefore the database will not be used to store notification history (but you will still receive notification history in your app log, on the info level).
To disable using database, set UNIVERSAL_NOTIFICATIONS_HISTORY_USE_DATABASE to False (default: True ), and to disable any history tracking, set UNIVERSAL_NOTIFICATIONS_HISTORY to False (default: True ). Project detail